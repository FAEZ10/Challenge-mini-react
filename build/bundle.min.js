
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
'use strict';

function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : String(i);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
      result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}

var CLASS = 'class';
var ROOT_WRAPPER = 'root';

var HOST_WRAPPER = 'host';
var INSERT = 1;
var DELETE = 2;
var UPDATE = 3;
var THREAD_TIME = 1;

var instantiate = function instantiate(fiber) {
  var instance = new fiber.type(fiber.props);
  instance.__fiber = fiber;
  return instance;
};
var findRoot = function findRoot(fiber) {
  var node = fiber;
  while (node.parent) {
    node = node.parent;
  }
  return node;
};

var childrenReconcile = function childrenReconcile(wipTree, newChildElements) {
  var elements = [].concat(newChildElements);
  var index = 0;
  var oldFiber = wipTree.alternate ? wipTree.alternate.child : null;
  var newFiber = null;
  while (index < elements.length || oldFiber != null) {
    var prevFiber = newFiber;
    var element = index < elements.length && elements[index];
    var sameType = oldFiber && element && element.type == oldFiber.type;
    if (sameType) {
      newFiber = {
        type: oldFiber.type,
        tag: oldFiber.tag,
        stateNode: oldFiber.stateNode,
        props: element.props,
        parent: wipTree,
        alternate: oldFiber,
        partialState: oldFiber.partialState,
        effectTag: UPDATE
      };
    }
    if (element && !sameType) {
      newFiber = {
        type: element.type,
        tag: typeof element.type === 'string' ? HOST_WRAPPER : CLASS,
        props: element.props,
        parent: wipTree,
        effectTag: INSERT
      };
    }
    if (oldFiber && !sameType) {
      oldFiber.effectTag = DELETE;
      wipTree.effects = wipTree.effects || [];
      wipTree.effects.push(oldFiber);
    }
    if (oldFiber) {
      oldFiber = oldFiber.sibling;
    }
    if (index == 0) {
      wipTree.child = newFiber;
    } else if (prevFiber && element) {
      prevFiber.sibling = newFiber;
    }
    index++;
  }
};
var childrenClone = function childrenClone(parentFiber) {
  var oldFiber = parentFiber.alternate;
  if (!oldFiber.child) {
    return;
  }
  var oldChild = oldFiber.child;
  var prevChild = null;
  while (oldChild) {
    var newChild = {
      type: oldChild.type,
      tag: oldChild.tag,
      stateNode: oldChild.stateNode,
      props: oldChild.props,
      partialState: oldChild.partialState,
      alternate: oldChild,
      parent: parentFiber
    };
    if (prevChild) {
      prevChild.sibling = newChild;
    } else {
      parentFiber.child = newChild;
    }
    prevChild = newChild;
    oldChild = oldChild.sibling;
  }
};
var removeFiber = function removeFiber(fiber, domParent) {
  var node = fiber;

  // eslint-disable-next-line no-constant-condition
  while (true) {
    if (node.tag == CLASS) {
      node = node.child;
      continue;
    }
    domParent.removeChild(node.stateNode);
    while (node != fiber && !node.sibling) {
      node = node.parent;
    }
    if (node == fiber) {
      return;
    }
    node = node.sibling;
  }
};

var _renderer = null;
var _queue = [];
var _nextMessage = null;
var _pending = null;
var setRenderer = function setRenderer(renderer) {
  return _renderer = renderer;
};
var addMessage = function addMessage(message) {
  _queue.push(message);
  requestIdleCallback(initConsumer);
};
var initConsumer = function initConsumer(time) {
  consumeQueue(time);
  if (_nextMessage || _queue.length > 0) {
    requestIdleCallback(initConsumer);
  }
};
var consumeQueue = function consumeQueue(time) {
  !_nextMessage && setNextMessage();
  while (_nextMessage && time.timeRemaining() > THREAD_TIME) {
    _nextMessage = consumeMessage(_nextMessage);
  }
  if (_pending) {
    pushAll(_pending);
  }
};
var setNextMessage = function setNextMessage() {
  var changes = _queue.shift();
  if (!changes) {
    return;
  }
  var instance = changes.instance,
    partialState = changes.partialState,
    dom = changes.dom,
    newProps = changes.newProps,
    from = changes.from;
  if (partialState) {
    instance.__fiber.partialState = partialState;
  }
  var root = from == ROOT_WRAPPER ? dom._rootContainerFiber : findRoot(instance.__fiber);
  _nextMessage = {
    tag: ROOT_WRAPPER,
    stateNode: dom || root.stateNode,
    props: newProps || root.props,
    alternate: root
  };
};
var consumeMessage = function consumeMessage(wipTree) {
  if (wipTree.tag == CLASS) {
    var instance = wipTree.stateNode;
    var isNewInstance = !instance;
    if (isNewInstance) {
      instance = wipTree.stateNode = instantiate(wipTree);
      instance.props = wipTree.props;
      instance.state = Object.assign({}, instance.state, wipTree.partialState);
      wipTree.partialState = null;
      var newChildElements = instance.render();
      childrenReconcile(wipTree, newChildElements);
      instance.componentDidMount();
    } else {
      var propsChanged = wipTree.props != instance.props;
      var stateChanged = wipTree.partialState;
      if (propsChanged || stateChanged) {
        var prevProps = instance.props;
        var prevState = instance.state;
        instance.props = wipTree.props;
        instance.state = Object.assign({}, instance.state, wipTree.partialState);
        wipTree.partialState = null;
        var _newChildElements = instance.render();
        childrenReconcile(wipTree, _newChildElements);
        instance.componentDidUpdate(prevProps, prevState);
      } else {
        childrenClone(wipTree);
      }
    }
  } else {
    if (!wipTree.stateNode) {
      wipTree.stateNode = _renderer.createElement(wipTree);
    }
    var _newChildElements2 = wipTree.props.children;
    childrenReconcile(wipTree, _newChildElements2);
  }
  if (wipTree.child) {
    return wipTree.child;
  }
  var uow = wipTree;
  while (uow) {
    threadDone(uow);
    if (uow.sibling) {
      return uow.sibling;
    }
    uow = uow.parent;
  }
};
var threadDone = function threadDone(fiber) {
  if (fiber.tag == CLASS) {
    fiber.stateNode.__fiber = fiber;
  }
  if (fiber.parent) {
    var childEffects = fiber.effects || [];
    var thisEffect = fiber.effectTag != null ? [fiber] : [];
    var parentEffects = fiber.parent.effects || [];
    fiber.parent.effects = parentEffects.concat(childEffects, thisEffect);
  } else {
    _pending = fiber;
  }
};
var pushAll = function pushAll(fiber) {
  fiber.effects.forEach(function (f) {
    pushOne(f);
  });
  fiber.stateNode._rootContainerFiber = fiber;
  _nextMessage = null;
  _pending = null;
};
var pushOne = function pushOne(fiber) {
  if (fiber.tag == ROOT_WRAPPER) {
    return;
  }
  var domParentFiber = fiber.parent;
  while (domParentFiber.tag == CLASS) {
    domParentFiber = domParentFiber.parent;
  }
  var domParent = domParentFiber.stateNode;
  if (fiber.effectTag == INSERT && fiber.tag == HOST_WRAPPER) {
    domParent.appendChild(fiber.stateNode);
  } else if (fiber.effectTag == UPDATE) {
    _renderer.propsUpdate(fiber.stateNode, fiber.alternate.props, fiber.props);
  } else if (fiber.effectTag == DELETE) {
    removeFiber(fiber, domParent);
  }
};

var Component = /*#__PURE__*/function () {
  function Component(props) {
    _classCallCheck(this, Component);
    this.props = props || {};
    this.state = this.state || {};
    this.componentDidMount = this.componentDidMount || function () {};
    this.componentDidUpdate = this.componentDidUpdate || function () {};
    this.componentWillUnmount = this.componentWillUnmount || function () {};
  }
  _createClass(Component, [{
    key: "setState",
    value: function setState(state) {
      var newState = typeof state === 'function' ? state(this.state) : state;
      var message = {
        from: CLASS,
        instance: this,
        partialState: newState
      };
      addMessage(message);
    }
  }]);
  return Component;
}();

var _excluded = ["tagName", "props", "componentClass"];
var CreateElement = (function (_ref) {
  var tagName = _ref.tagName,
    _ref$props = _ref.props,
    props = _ref$props === void 0 ? {} : _ref$props,
    componentClass = _ref.componentClass,
    rest = _objectWithoutProperties(_ref, _excluded);
  var type = tagName ? tagName : componentClass;
  Object.assign(props, rest);
  return {
    type: type,
    props: props
  };
});

var MiniReact = {
  Component: Component,
  CreateElement: CreateElement
};

var inserted = function inserted(prev, next) {
  return function (key) {
    return prev[key] !== next[key];
  };
};
var deleted = function deleted(prev, next) {
  return function (key) {
    return !(key in next);
  };
};
var event = function event(name) {
  return name.startsWith('on');
};
var attribute = function attribute(name) {
  return !event(name) && name != 'children' && name != 'style';
};

var TEXT_ELEMENT = 'TEXT ELEMENT';

var MiniReactDOM = {
  render: function render(element, container) {
    setRenderer(MiniReactDOM);
    var message = {
      from: ROOT_WRAPPER,
      dom: container,
      newProps: {
        children: element
      }
    };
    addMessage(message);
  },
  createElement: function createElement(el) {
    var text = el.type === TEXT_ELEMENT;
    var dom = text ? document.createTextNode('') : document.createElement(el.type);
    MiniReactDOM.propsUpdate(dom, [], el.props);
    return dom;
  },
  propsUpdate: function propsUpdate(dom, previous, next) {
    previous && Object.keys(previous).filter(attribute).filter(deleted(previous, next)).forEach(function (name) {
      dom[name] = null;
    });
    previous && Object.keys(previous).filter(event).filter(function (key) {
      return !(key in next) || inserted(previous, next)(key);
    }).forEach(function (name) {
      var eventType = name.toLowerCase().substring(2);
      !dom.props && dom.removeEventListener(eventType, previous[name]);
    });
    next && Object.keys(next).filter(attribute).filter(inserted(previous, next)).forEach(function (name) {
      dom[name] = next[name];
    });
    previous && (previous.style = previous.style || {});
    next && (next.style = next.style || {});
    next && Object.keys(next.style).filter(inserted(previous.style, next.style)).forEach(function (key) {
      dom.style[key] = next.style[key];
    });
    previous && next && Object.keys(previous.style).filter(deleted(previous.style, next.style)).forEach(function (key) {
      dom.style[key] = '';
    });
    previous && next && Object.keys(next).filter(event).filter(inserted(previous, next)).forEach(function (name) {
      var eventType = name.toLowerCase().substring(2);
      !dom.props && dom.addEventListener(eventType, next[name]);
    });
  }
};

var BrowserRouter = /*#__PURE__*/function (_Component) {
  _inherits(BrowserRouter, _Component);
  var _super = _createSuper(BrowserRouter);
  function BrowserRouter(props) {
    var _this;
    _classCallCheck(this, BrowserRouter);
    _this = _super.call(this, props);
    _this.state = {
      currentPath: window.location.pathname,
      componentInstances: {}
    };
    _this.handleUrlChange = _this.handleUrlChange.bind(_assertThisInitialized(_this));
    window.addEventListener('popstate', _this.handleUrlChange);
    _this.initializeComponentInstances(props.routes);
    return _this;
  }
  _createClass(BrowserRouter, [{
    key: "initializeComponentInstances",
    value: function initializeComponentInstances(routes) {
      var _this2 = this;
      routes.forEach(function (route) {
        if (!_this2.state.componentInstances[route.path]) {
          var instance = new route.component();
          instance.componentDidMount();
          _this2.state.componentInstances[route.path] = instance;
        }
      });
    }
  }, {
    key: "handleUrlChange",
    value: function handleUrlChange() {
      var newPath = window.location.pathname;
      var matchingRoute = this.props.routes.find(function (route) {
        return route.path === newPath;
      });
      if (!matchingRoute) {
        window.history.pushState({}, '', '/');
        this.setState({
          currentPath: '/'
        });
      } else {
        var prevInstance = this.state.componentInstances[this.state.currentPath];
        if (prevInstance && prevInstance.componentWillUnmount) {
          prevInstance.componentWillUnmount();
        }
        this.setState({
          currentPath: newPath
        });
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      window.removeEventListener('popstate', this.handleUrlChange);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$state = this.state,
        currentPath = _this$state.currentPath,
        componentInstances = _this$state.componentInstances;
      var componentInstance = componentInstances[currentPath] || componentInstances['/'];
      return CreateElement({
        componentClass: componentInstance.constructor,
        props: _objectSpread2({}, componentInstance.props)
      });
    }
  }]);
  return BrowserRouter;
}(Component);

var Route = /*#__PURE__*/_createClass(function Route(path, component) {
  _classCallCheck(this, Route);
  this.path = path;
  this.component = component;
});

var Home = /*#__PURE__*/function (_MiniReact$Component) {
  _inherits(Home, _MiniReact$Component);
  var _super = _createSuper(Home);
  function Home() {
    _classCallCheck(this, Home);
    return _super.apply(this, arguments);
  }
  _createClass(Home, [{
    key: "render",
    value: function render() {
      return MiniReact.CreateElement({
        tagName: 'div',
        props: {
          className: 'home'
        },
        children: [MiniReact.CreateElement({
          tagName: 'h1',
          props: {
            textContent: 'Bienvenue sur la page d\'accueil'
          }
        }), MiniReact.CreateElement({
          tagName: 'p',
          props: {
            textContent: 'Ceci est la page d\'accueil de notre application.'
          }
        })]
      });
    }
  }]);
  return Home;
}(MiniReact.Component);

var About = /*#__PURE__*/function (_MiniReact$Component) {
  _inherits(About, _MiniReact$Component);
  var _super = _createSuper(About);
  function About() {
    _classCallCheck(this, About);
    return _super.apply(this, arguments);
  }
  _createClass(About, [{
    key: "render",
    value: function render() {
      return MiniReact.CreateElement({
        tagName: 'div',
        props: {
          className: 'about'
        },
        children: [MiniReact.CreateElement({
          tagName: 'h1',
          props: {
            textContent: 'Ã€ propos de Nous'
          }
        }), MiniReact.CreateElement({
          tagName: 'p',
          props: {
            textContent: 'Informations sur notre entreprise, notre mission et nos valeurs.'
          }
        })]
      });
    }
  }]);
  return About;
}(MiniReact.Component);

var routes = [new Route("/", Home), new Route("/about", About)];

var App = CreateElement({
  componentClass: BrowserRouter,
  props: {
    routes: routes
  }
});
MiniReactDOM.render(App, document.getElementById('root'));
